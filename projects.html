<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/html">
<head>
    <meta name="viewport" content="with=device-width, initial-scale=1.0">
    <title>Sabine Laurence Personal Website</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body>
<section class="header">
    <nav>
        <a href="index.html"><img src="src/main/resources/sabine%20laurence%20logo.pdf"></a>
        <div class="nav-links" id="navLinks">
            <i class="fa fa-times" onclick="hideMenu()"></i>
            <ul>
                <li><a href="index.html">HOME</a></li>
                <li><a href="courses.html">COURSES</a></li>
                <!--                   <li><a href="about.html">ABOUT</a></li> -->
                <li><a href="projects.html">PROJECTS</a></li>
                <!--  <li><a href="experience.html">EXPERIENCE</a></li> -->
            </ul>
        </div>
        <i class="fa fa-bars" onclick="showMenu()"></i>
    </nav>
    <div class="text-box">
        <h1>Hi! I'm Sabine Laurence</h1>
        <p>laurence.s@northeastern.edu | (408) 409-3664</p>
    </div>
</section>

<section class="projects">
    <h1>Projects I've Worked On</h1>
    <p> </p>

    <div class="col">
        <div class="proj-col">
            <h3>Maze Game</h3>
            <p>In Foundations of Computer Science 2, our final project was to work with a partner to develop a self generating and solving maze. The user would be able to input three variables to the command line: integers to represent the height and width of the maze, as well as a boolean which determined if the maze would be solved breath-first (true), or depth-first (false). From there, when the program is run, an auto-generated maze would appear. You could then watch in real time, through visual animation, as the program searches to find a solution to the maze. </p>
                <p>In order to implement the self-generating maze, our project utilizes a modified version of Kruskal's algorithm. We represent the maze as a grid of nodes, each connected to its neighbors (up, down, left, right) by edges. The program starts by initializing all nodes and edges, assigning random weights to the edges. These edges are then sorted based on their weights, in ascending order. The algorithm then iterates through the sorted edges, adding each edge to the maze if it connects two disjoint sets of nodes. This process continues until a spanning tree is formed.</p>
                <p>For the maze solving part, the program employs either breadth-first or depth-first search, based on the user's choice. Using a specialized collection (queue for breath or stack for depth) to manage the traversal, the algorithm explores the maze from the starting point to find a path to the destination. During this exploration, the program visually highlights the nodes and edges involved in the current path, providing a real-time animation of the solving process. The final result is an interactive Java application that not only generates intriguing mazes but also visually demonstrates how it navigates through the maze to find a solution.</p>
            <div class="vid-container">
            <video width="640" height="360" controls>
                <source src="src/main/resources/maze_game_demo.mp4" type="video/mp4">
                Your browser does not support the video tag.
            </video>
                </div>
            <a href="https://github.com/slaurence1003/MazeGame" class="pbtn">Check out the code!</a>
        </div>
        <div class="proj-col">
            <h3>Jetsetter Database</h3>
            <p>For our database design class, our final project was to work in groups of 5 to conceptualize, design, and implement a sophisticated database-driven application. My group chose to focus on airline management, developing an application that empowers various user roles to efficiently handle, access, and modify data pertaining to flights and flight management. Our target audience included passengers, airline managers, flight crew, and viewers, each with distinct roles and access levels.
</p><p>
                Passengers have the ability to effortlessly view, edit, and book their flights, while airline managers can schedule, edit, and delete flights. The flight crew has access to their flight schedules and the capability to modify schedule information, and viewers can peruse existing flights and general information. To realize this vision, we began by defining client requirements and proceeded to create localized data models and entity-relationship (ER) diagrams for each user persona. These were then merged into a comprehensive global ER diagram, serving as the basis for our relational model, which we then implemented in MySQL. The database was populated using auto-generated data.
        </p><p>
                With the MySQL database in place, we developed a REST API as the data access layer using Python and the Flask framework. The API was comprised of a robust set of nearly 30 endpoints, ensuring seamless communication between user interfaces and the database. We incorporated a diverse range of 'GET,' 'PUT,' 'POST,' and 'DELETE' methods to enhance the overall usability of our application.
        </p><p>
                To bring our database-driven application to life, we leveraged Appsmith, an intuitive and efficient platform for designing user interfaces. Customized user pages were created for each persona, delivering a tailored and user-friendly experience. The application was seamlessly connected to our API, enabling comprehensive functionality for our users. Due to time limits and scope of the project, we were only able to make use of 2-3 endpoints for each user, but vital functionality is modeled in our application. Given more time, we would be able to have implemented all endpoints within our application to ensure full functionality for each user.
        </p><p>
                We successfully designed and implemented ten distinct pages, prioritizing a high-quality product that met the diverse needs of our user base. The combination of MySQL for the database, Appsmith for frontend development, and Flask for the REST API layer culminated in a well-rounded and functional airline management application.</p>
        </div>

    </div>
</section>

<script>
    var navLinks = document.getElementById(navLinks);

    function showMenu(){
        navLinks.style.right = "0";
    }
    function hideMenu(){
        navLinks.style.right = "-200px";
    }
</script>

</body>

</html>